From dc1c2d5b5415fc25c3847f9ace60134d8e23b7c4 Mon Sep 17 00:00:00 2001
From: Sai Praneeth <sai.praneeth.prakhya@intel.com>
Date: Mon, 19 Dec 2016 16:24:45 -0800
Subject: [PATCH] x86/efi: Install new_memmap at the end of efi_late_init()

With commit dca0f971ea6f ("efi: Add efi_memmap_init_late() for permanent
EFI memmap") we discard original memory map passed by firmware and
replace it with the new memory map built by kernel which has efi
runtime/boottime regions only. But with patches "Detect illegal access to
UEFI Boot Services memory regions" kernel maps *only* efi runtime
regions and populates new_memmap with runtime regions only and hence
discarding efi boot time regions and we have also lost the original
memmap passed by firmware because the above mentioned commit replaces it
with a newly built one.

When (buggy) firmware tries to access boot time regions (which it's
supposedly not to), a page fault occurs and kernel tries to map the
requested boot time region again into page tables but the kernel fails
to find the region in new_memmap because we haven't mapped it into
new_memmap (because we want to catch issues of this kind) and hence
kernel panics.

In-order to fix this let's replace memmap passed by firmware with
new_memmap *only* when all the efi stuff is done i.e at the end of
efi_late_init(). We also cannot unmap original memmap right after
call to Set Virtual Address Map because efi_bgrt_init() requires access
to boot time region (it uses this region to store the image) and hence
can be done only after efi_bgrt_init().

Signed-off-by: Sai Praneeth Prakhya <sai.praneeth.prakhya>
---
 arch/x86/platform/efi/efi.c | 38 ++++++++++++++++++++++++--------------
 1 file changed, 24 insertions(+), 14 deletions(-)

diff --git a/arch/x86/platform/efi/efi.c b/arch/x86/platform/efi/efi.c
index 0eec9f6c2a66..c7cefeb4f425 100644
--- a/arch/x86/platform/efi/efi.c
+++ b/arch/x86/platform/efi/efi.c
@@ -55,6 +55,7 @@
 
 static struct efi efi_phys __initdata;
 static efi_system_table_t efi_systab __initdata;
+static void *new_memmap __initdata = NULL;
 
 static efi_config_table_type_t arch_tables[] __initdata = {
 #ifdef CONFIG_X86_UV
@@ -478,7 +479,30 @@ void __init efi_init(void)
 
 void __init efi_late_init(void)
 {
+	int count = 0;
+	unsigned long pa;
+	efi_memory_desc_t *md;
+	pa = __pa(new_memmap);
+
+	for_each_efi_memory_desc(md) {
+
+		if (md->attribute & EFI_MEMORY_RUNTIME)
+			count++;
+	}
+
 	efi_bgrt_init();
+
+	/*
+	 * Unregister the early EFI memmap from efi_init() and install
+	 * the new EFI memory map.
+	 */
+	efi_memmap_unmap();
+
+	if (efi_memmap_init_late(pa, efi.memmap.desc_size * count)) {
+		pr_err("Failed to remap late EFI memory map\n");
+		clear_bit(EFI_RUNTIME_SERVICES, &efi.flags);
+		return;
+	}
 }
 
 void __init efi_set_executable(efi_memory_desc_t *md, bool executable)
@@ -863,7 +887,6 @@ static void __init kexec_enter_virtual_mode(void)
 static void __init __efi_enter_virtual_mode(void)
 {
 	int count = 0, pg_shift = 0;
-	void *new_memmap = NULL;
 	efi_status_t status;
 	unsigned long pa;
 
@@ -885,19 +908,6 @@ static void __init __efi_enter_virtual_mode(void)
 
 	pa = __pa(new_memmap);
 
-	/*
-	 * Unregister the early EFI memmap from efi_init() and install
-	 * the new EFI memory map that we are about to pass to the
-	 * firmware via SetVirtualAddressMap().
-	 */
-	efi_memmap_unmap();
-
-	if (efi_memmap_init_late(pa, efi.memmap.desc_size * count)) {
-		pr_err("Failed to remap late EFI memory map\n");
-		clear_bit(EFI_RUNTIME_SERVICES, &efi.flags);
-		return;
-	}
-
 	BUG_ON(!efi.systab);
 
 	if (efi_setup_page_tables(pa, 1 << pg_shift)) {
-- 
2.1.4

